<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gemini Live ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ–‡å­—èµ·ã“ã—</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif; margin: 24px; }
    .container { max-width: 920px; margin: 0 auto; }
    h1 { font-size: 22px; margin-bottom: 8px; }
    .status-message { padding: 10px 12px; border-radius: 8px; background: #f4f6f8; margin: 12px 0; }
    .status-message.success { background: #eef9f0; }
    .status-message.error { background: #ffecec; color: #c62828; }
    textarea { width: 100%; box-sizing: border-box; padding: 10px; height: 260px; }
    .controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .btn { padding: 8px 14px; border: 1px solid #ddd; border-radius: 8px; background: white; cursor: pointer; }
    .btn[disabled] { opacity: .5; cursor: not-allowed; }
    .btn.primary { background: #1967d2; color: white; border-color: #1967d2; }
    .btn.danger { background: #c62828; color: white; border-color: #c62828; }
    .hint { color: #666; font-size: 13px; }
    .llm-area { margin-top: 24px; }
    pre { white-space: pre-wrap; word-break: break-word; background: #fafafa; padding: 12px; border-radius: 8px; border: 1px solid #eee; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Gemini Live ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ–‡å­—èµ·ã“ã—</h1>

    <div id="status" class="status-message">ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: æº–å‚™å®Œäº†ã€‚ã€Œæ–‡å­—èµ·ã“ã—é–‹å§‹ã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚</div>

    <div class="controls" style="margin-bottom: 12px;">
      <button id="start" class="btn primary">ğŸ¤ æ–‡å­—èµ·ã“ã—é–‹å§‹</button>
      <button id="stop" class="btn danger" disabled>â¹ åœæ­¢</button>
      <span class="hint">â€» ãƒ–ãƒ©ã‚¦ã‚¶ãŒãƒã‚¤ã‚¯ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’æ±‚ã‚ã¾ã™</span>
    </div>

    <textarea id="transcript" placeholder="ã“ã“ã«ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§æ–‡å­—èµ·ã“ã—ãŒè¡¨ç¤ºã•ã‚Œã¾ã™..."></textarea>

    <div class="llm-area">
      <div class="controls">
        <button id="summarize" class="btn" disabled>âœ¨ è¦ç´„ã‚’ç”Ÿæˆ</button>
        <button id="terms" class="btn" disabled>âœ¨ å°‚é–€ç”¨èªã‚’ãƒã‚§ãƒƒã‚¯</button>
        <span class="hint">ï¼ˆåœæ­¢å¾Œã«å®Ÿè¡Œã§ãã¾ã™ï¼‰</span>
      </div>
      <div id="llmOut" style="margin-top: 10px;"></div>
    </div>
  </div>

  <script type="module">
    // ===== è¨­å®š =====
    const GEMINI_LIVE_ENDPOINT = 'wss://generativelanguage.googleapis.com/ws/google.ai.generativelanguage.v1alpha.GenerativeService.BidiGenerateContent';
    const API_KEY_ENDPOINT = '/api-key';                // APIã‚­ãƒ¼ã‚µãƒ¼ãƒ
    const TEXT_GEN_ENDPOINT = '/text-generate';         // ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆãƒ—ãƒ­ã‚­ã‚·
    const SAMPLE_RATE = 16000;
    const CHUNK_SIZE = 2048; // ScriptProcessor ã®ãƒãƒƒãƒ•ã‚¡

    // ===== DOM =====
    const $status = document.getElementById('status');
    const $start = document.getElementById('start');
    const $stop = document.getElementById('stop');
    const $txt = document.getElementById('transcript');
    const $sum = document.getElementById('summarize');
    const $terms = document.getElementById('terms');
    const $out = document.getElementById('llmOut');

    // ===== çŠ¶æ…‹ =====
    let ws = null;            // WebSocket æ¥ç¶š
    let audioContext = null;  // WebAudio
    let micStream = null;     // ãƒã‚¤ã‚¯
    let sysStream = null;     // ã‚·ã‚¹ãƒ†ãƒ éŸ³å£°ï¼ˆç”»é¢å…±æœ‰ï¼‰
    let recorder = null;      // ScriptProcessorNode

    function setStatus(msg, type='') {
      $status.textContent = `ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: ${msg}`;
      $status.className = `status-message ${type}`.trim();
    }
    function updateButtons(running) {
      $start.disabled = running;
      $stop.disabled = !running;
      const hasText = ($txt.value.trim().length > 0);
      $sum.disabled = running || !hasText;
      $terms.disabled = running || !hasText;
    }

    async function fetchApiKey() {
      const res = await fetch(API_KEY_ENDPOINT, { method: 'POST' });
      if (!res.ok) throw new Error(`APIã‚­ãƒ¼å–å¾—ã«å¤±æ•—: ${res.status}`);
      const { apiKey } = await res.json();
      if (!apiKey) throw new Error('APIã‚­ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒä¸æ­£');
      return apiKey;
    }

async function startTranscription() {
  setStatus('éŸ³å£°ã‚¹ãƒˆãƒªãƒ¼ãƒ å–å¾—ä¸­...');
  updateButtons(true);
  $out.innerHTML = '';
  $txt.value = '';

  try {
    // 1) ãƒã‚¤ã‚¯å–å¾—
    const micOnly = true;
    micStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
    setStatus('ãƒã‚¤ã‚¯å–å¾—å®Œäº†ã€‚æ¥ç¶šæº–å‚™ä¸­...');

    // 2) WebAudio æº–å‚™ï¼ˆ16kHzï¼‰
    audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SAMPLE_RATE });
    const micSrc = audioContext.createMediaStreamSource(micStream);

    let merger = null;
    if (!micOnly) {
      // ã‚·ã‚¹ãƒ†ãƒ éŸ³å£°ã‚‚å–ã‚ŠãŸã„å ´åˆ
      try {
        sysStream = await navigator.mediaDevices.getDisplayMedia({
          video: true,
          audio: { systemAudio: "include", suppressLocalAudioPlayback: false }
        });
        sysStream.getVideoTracks().forEach(t => t.stop());
      } catch (e) {
        console.warn('displayMedia unavailable, continue with mic only', e);
        sysStream = null;
      }
    }

    // å…¥åŠ›ãƒãƒ£ãƒ³ãƒãƒ«ã‚’å®‰å…¨ã« 1ch ã«ã¾ã¨ã‚ã‚‹
    const inChannels = (micOnly || !sysStream) ? 1 : 2;
    merger = audioContext.createChannelMerger(inChannels);
    micSrc.connect(merger, 0, 0);

    if (!micOnly && sysStream) {
      const sysTracks = sysStream.getAudioTracks();
      if (sysTracks.length > 0) {
        const sysSrc = audioContext.createMediaStreamSource(sysStream);
        sysSrc.connect(merger, 0, 1);
        setStatus('ãƒã‚¤ã‚¯ + ã‚·ã‚¹ãƒ†ãƒ éŸ³å£°ï¼ˆå¯èƒ½ãªã‚‰ï¼‰ã‚’é€ä¿¡ã—ã¾ã™...');
      } else {
        setStatus('ã‚·ã‚¹ãƒ†ãƒ éŸ³å£°ãƒˆãƒ©ãƒƒã‚¯ãŒè¦‹ã¤ã‹ã‚‰ãšã€ãƒã‚¤ã‚¯ã®ã¿ã§ç¶šè¡Œã—ã¾ã™ã€‚');
      }
    }

    // ScriptProcessor ã¯ç’°å¢ƒå·®ã§ NotSupported ã«ãªã‚Šã†ã‚‹ã®ã§ try ã§ä¿è­·
    try {
      recorder = audioContext.createScriptProcessor(CHUNK_SIZE, inChannels, 1);
    } catch (e) {
      recorder = audioContext.createScriptProcessor(2048, inChannels, 1);
    }
    merger.connect(recorder);
    recorder.connect(audioContext.destination);

    // 3) APIã‚­ãƒ¼ã§ Live API æ¥ç¶š
    const apiKey = await fetchApiKey();
    const url = `${GEMINI_LIVE_ENDPOINT}?key=${encodeURIComponent(apiKey)}`;
    ws = new WebSocket(url);
    ws.binaryType = "arraybuffer";

    ws.onopen = async () => {
      setStatus('Gemini Live ã«æ¥ç¶šã—ã¾ã—ãŸã€‚ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ä¸­...', 'success');
      try { await audioContext.resume(); } catch {}

      // æ­£ã—ã„ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡
      const init = {
        setup: {
          model: 'models/gemini-2.0-flash-live-001',
          generationConfig: {
            responseModalities: ['TEXT'],
          },
          systemInstruction: {
            parts: [{
              text: 'ã‚ãªãŸã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®éŸ³å£°å…¥åŠ›ã‚’å³å¯†ã«æ–‡å­—èµ·ã“ã—ã™ã‚‹ã‚¨ãƒ³ã‚¸ãƒ³ã§ã™ã€‚å¥èª­ç‚¹å«ã‚æ­£ç¢ºãªæ—¥æœ¬èªã§æ›¸ãèµ·ã“ã—ã¦ãã ã•ã„ã€‚å¿œç­”ã‚„è¦ç´„ã¯ã—ãªã„ã§ãã ã•ã„ã€‚'
            }]
          }
        }
      };
      console.log('Sending setup:', JSON.stringify(init, null, 2));
      ws.send(JSON.stringify(init));
    };

    let setupComplete = false;

    ws.onmessage = (ev) => {
      // ArrayBufferã‚’ãƒ†ã‚­ã‚¹ãƒˆã«ãƒ‡ã‚³ãƒ¼ãƒ‰
      let messageText;
      if (ev.data instanceof ArrayBuffer) {
        const decoder = new TextDecoder('utf-8');
        messageText = decoder.decode(ev.data);
      } else {
        messageText = ev.data;
      }

      // JSONãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å‡¦ç†
      try {
        const data = JSON.parse(messageText);
        console.log('Received message:', JSON.stringify(data, null, 2));

        // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãƒã‚§ãƒƒã‚¯
        if (data.error) {
          console.error('Server error:', data.error);
          setStatus(`ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼: ${JSON.stringify(data.error)}`, 'error');
        }

        // ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—å®Œäº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å¾…ã¤
        if (data.setupComplete) {
          console.log('Setup complete, starting audio transmission...');
          setupComplete = true;
          setStatus('ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—å®Œäº†ã€‚æ–‡å­—èµ·ã“ã—ã‚’é–‹å§‹ã—ã¾ã™ã€‚', 'success');

          // ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—å®Œäº†å¾Œã€éŸ³å£°é€ä¿¡ã‚’é–‹å§‹
          let audioChunkCount = 0;
          recorder.onaudioprocess = (e) => {
            if (!ws || ws.readyState !== WebSocket.OPEN || !setupComplete) return;

            const nCh = e.inputBuffer.numberOfChannels;
            const ch0 = nCh > 0 ? e.inputBuffer.getChannelData(0) : new Float32Array(0);
            const ch1 = nCh > 1 ? e.inputBuffer.getChannelData(1) : null;

            const len = ch0.length;
            const pcm16 = new Int16Array(len);
            for (let i = 0; i < len; i++) {
              const r = ch1 ? ch1[i] : 0;
              const mixed = ((ch0[i] || 0) + (r || 0)) / (ch1 ? 2 : 1);
              const s = Math.max(-1, Math.min(1, mixed));
              pcm16[i] = (s * 0x7fff) | 0;
            }

            // realtimeInputãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ã—ã¦éŸ³å£°ã‚’é€ä¿¡ï¼ˆæ­£ã—ã„ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆï¼‰
            const uint8Array = new Uint8Array(pcm16.buffer);
            let binary = '';
            for (let i = 0; i < uint8Array.byteLength; i++) {
              binary += String.fromCharCode(uint8Array[i]);
            }
            const base64Audio = btoa(binary);

            const audioMsg = {
              realtimeInput: {
                audio: {
                  mimeType: 'audio/pcm;rate=16000',
                  data: base64Audio
                }
              }
            };
            ws.send(JSON.stringify(audioMsg));

            // æœ€åˆã®æ•°ãƒãƒ£ãƒ³ã‚¯ã ã‘ãƒ­ã‚°å‡ºåŠ›
            if (audioChunkCount < 3) {
              console.log(`Sending audio chunk #${audioChunkCount}, size: ${pcm16.buffer.byteLength} bytes`);
              if (audioChunkCount === 0) {
                console.log('Sample audio message:', audioMsg);
              }
              audioChunkCount++;
            }
          };
        }

        // ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ï¼ˆæ–‡å­—èµ·ã“ã—çµæœï¼‰ã‚’å‡¦ç†
        if (data.serverContent) {
          console.log('serverContent received:', data.serverContent);

          // modelTurn.parts[0].text ã‹ã‚‰å–å¾—
          const text = data.serverContent.modelTurn?.parts?.[0]?.text;
          if (text) {
            console.log('Transcription text:', text);
            $txt.value += text;
            $txt.scrollTop = $txt.scrollHeight;
          } else {
            console.log('serverContent has no text in modelTurn.parts[0]');
          }
        }

        // ãã®ä»–ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¿ã‚¤ãƒ—ã‚‚ãƒ­ã‚°å‡ºåŠ›
        if (data.toolCall) {
          console.log('toolCall received:', data.toolCall);
        }
        if (data.toolCallCancellation) {
          console.log('toolCallCancellation received:', data.toolCallCancellation);
        }
      } catch (err) {
        console.warn('Message parse error:', err, 'Data:', ev.data);
      }
    };

    ws.onerror = (err) => {
      console.error('WebSocket error', err);
      setStatus('WebSocketã‚¨ãƒ©ãƒ¼ã€‚ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚', 'error');
      stopTranscription();
    };

    ws.onclose = (ev) => {
      console.warn("WS closed:", {code: ev.code, reason: ev.reason});
      setStatus(`æ¥ç¶šãŒåˆ‡æ–­ã•ã‚Œã¾ã—ãŸï¼ˆcode=${ev.code} reason=${ev.reason || 'n/a'}ï¼‰ã€‚å†é–‹ã§ãã¾ã™ã€‚`);
      updateButtons(false);
    };
  } catch (e) {
    console.error('startTranscription error', e);
    const msg = (e?.name === 'NotAllowedError' || e?.name === 'NotFoundError')
      ? 'æ¨©é™ã‚¨ãƒ©ãƒ¼: ãƒã‚¤ã‚¯ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹è¨±å¯ãŒå¿…è¦ã§ã™ã€‚ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦è¨±å¯ã—ã¦ãã ã•ã„ã€‚'
      : `åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${e?.message || e}`;
    setStatus(msg, 'error');
    updateButtons(false);
  }
}

    function stopTranscription() {
      setStatus('åœæ­¢å‡¦ç†ä¸­...');
      // WebSocket
      try { ws?.close(1000, 'user close'); } catch(_){}
      ws = null;
      // Audio
      try { recorder?.disconnect(); } catch(_){}
      recorder = null;
      try { audioContext?.close(); } catch(_){}
      audioContext = null;
      try { micStream?.getTracks().forEach(t => t.stop()); } catch(_){}
      micStream = null;
      try { sysStream?.getTracks().forEach(t => t.stop()); } catch(_){}
      sysStream = null;

      setStatus('åœæ­¢å®Œäº†ã€‚åˆ†ææ©Ÿèƒ½ã‚’ä½¿ãˆã¾ã™ã€‚');
      updateButtons(false);
    }

    async function callTextGen(systemInstruction, userQuery, model = 'gemini-2.0-flash-live-001') {
      const payload = { systemInstruction, userQuery, model };
      const res = await fetch(TEXT_GEN_ENDPOINT, {
        method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
      });
      if (!res.ok) throw new Error(`ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆã«å¤±æ•—: ${res.status}`);
      const data = await res.json();
      return data.text || '';
    }

    async function summarize() {
      const t = $txt.value.trim();
      if (!t) return;
      $sum.disabled = $terms.disabled = true;
      $out.innerHTML = '<pre>âœ¨ è¦ç´„ã‚’ç”Ÿæˆä¸­...</pre>';
      try {
        const sys = 'ã‚ãªãŸã¯ãƒ—ãƒ­ã®ã‚µãƒãƒ©ã‚¤ã‚¶ãƒ¼ã§ã™ã€‚æä¾›ã•ã‚ŒãŸæ—¥æœ¬èªã®ä¼šè­°ã¾ãŸã¯ä¼šè©±ã®æ–‡å­—èµ·ã“ã—ã‚’èª­ã¿ã€ä¸»è¦ãªè«–ç‚¹ã€æ±ºå®šäº‹é …ã€æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’å«ã‚€ç°¡æ½”ãªç®‡æ¡æ›¸ãã®è¦ç´„ã‚’æ—¥æœ¬èªã§ä½œæˆã—ã¦ãã ã•ã„ã€‚';
        const uq = `ä»¥ä¸‹ã®æ–‡å­—èµ·ã“ã—ã‚’è¦ç´„ã—ã¦ãã ã•ã„:\n\n---\n${t}`;
        const text = await callTextGen(sys, uq);
        $out.innerHTML = `<h3>è¦ç´„çµæœ</h3><pre>${text}</pre>`;
        setStatus('è¦ç´„ãŒå®Œäº†ã—ã¾ã—ãŸã€‚', 'success');
      } catch (e) {
        $out.innerHTML = `<pre style="color:#c62828">åˆ†æã‚¨ãƒ©ãƒ¼: ${e?.message || e}</pre>`;
        setStatus('è¦ç´„ã«å¤±æ•—ã—ã¾ã—ãŸã€‚', 'error');
      } finally {
        updateButtons(false);
      }
    }

    async function terms() {
      const t = $txt.value.trim();
      if (!t) return;
      $sum.disabled = $terms.disabled = true;
      $out.innerHTML = '<pre>âœ¨ å°‚é–€ç”¨èªã‚’åˆ†æä¸­...</pre>';
      try {
        const sys = 'ã‚ãªãŸã¯å­¦è¡“çš„ãªã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã§ã™ã€‚æä¾›ã•ã‚ŒãŸæ—¥æœ¬èªã®ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ã€å°‚é–€çš„/æŠ€è¡“çš„ãªç”¨èªã‚’æœ€å¤§5ã¤æŠ½å‡ºã—ã€éå°‚é–€å®¶ã«ã‚‚åˆ†ã‹ã‚‹ç°¡æ½”ã§æ­£ç¢ºãªæ—¥æœ¬èªã®èª¬æ˜ã‚’å‡ºåŠ›ã—ã¦ãã ã•ã„ã€‚å‡ºåŠ›ã¯ã€Œã€ç”¨èªã€‘: èª¬æ˜æ–‡ã€ã®ç®‡æ¡æ›¸ãã€‚';
        const uq = `ä»¥ä¸‹ã®æ–‡å­—èµ·ã“ã—ã‹ã‚‰å°‚é–€ç”¨èªã‚’æŠ½å‡ºã—ã€èª¬æ˜ã—ã¦ãã ã•ã„:\n\n---\n${t}`;
        const text = await callTextGen(sys, uq);
        $out.innerHTML = `<h3>å°‚é–€ç”¨èªåˆ†æçµæœ</h3><pre>${text}</pre>`;
        setStatus('å°‚é–€ç”¨èªåˆ†æãŒå®Œäº†ã—ã¾ã—ãŸã€‚', 'success');
      } catch (e) {
        $out.innerHTML = `<pre style="color:#c62828">åˆ†æã‚¨ãƒ©ãƒ¼: ${e?.message || e}</pre>`;
        setStatus('å°‚é–€ç”¨èªåˆ†æã«å¤±æ•—ã—ã¾ã—ãŸã€‚', 'error');
      } finally {
        updateButtons(false);
      }
    }

    // ===== ã‚¤ãƒ™ãƒ³ãƒˆ =====
    $start.addEventListener('click', startTranscription);
    $stop.addEventListener('click', stopTranscription);
    $sum.addEventListener('click', summarize);
    $terms.addEventListener('click', terms);

    // åˆæœŸ
    updateButtons(false);
  </script>
</body>
</html>
